- 基础概念
  collapsed:: true
	- 控制反转 IOC：反转了**对依赖对象的获取和管理**的控制权。
		- 传统模式：对象要使用其他对象的功能，需要自己负责创建（查找）。
		- 反转（IoC）：对象不在管理依赖，而是使用外部IoC容器管理（创建、查找），然后在注入给这个对象。
	- 依赖注入 DI
		- DI则是IoC的具体模式，由容器**在运行时**将依赖关系“注入”到组件中。
- 装饰器，装饰器本质上是一个**高阶函数**，可作用于类、方法、访问符（getter\setter）、类属性以及方法参数，可以获取并修改被作用元素的元信息。
  collapsed:: true
	- Typescript启用装饰器语法
	  ```json
	  // tsconfig.json
	  {
	      "compilerOptions": {
	          "target": "ES5",
	          "experimentalDecorators": true
	      }
	  }
	  ```
	- 基本语法
	  collapsed:: true
		- 装饰器使用`@expression`形式，`expression`求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。
		- ```typescript
		  // 装饰器
		  function sealed(target: any) {
		    // do something
		  }
		  
		  @sealed
		  class Obj {}
		  
		  // 装饰器工厂
		  function color(value: string) { // 工厂函数
		    return function(target: any) { // 装饰器
		      // do something
		    }
		  }
		  
		  /**
		  * 装饰器组合，多个装饰器应用于同一个声明上执行步骤：
		  * 由上至下依次对装饰器表达式求值。(工厂函数)
		  * 求值的结果会被当作函数，由下至上依次调用。（装饰器）
		  */
		  // 以下求值方式与复合函数求值类似，复合结果等同于foo(bar(X))
		  @foo
		  @bar
		  class X {}
		  
		  function foo() {
		    console.log('foo(): evaluated');
		    return function (_target: any) {
		      console.log('foo(): called');
		    };
		  }
		  
		  function bar() {
		    console.log('bar(): evaluated');
		    return function (_target: any) {
		      console.log('bar(): called');
		    };
		  }
		  
		  @foo()
		  @bar()
		  class Person {
		    constructor() {}
		  }
		  
		  new Person();
		  // foo(): evaluated
		  // bar(): evaluated
		  // foo(): called
		  // bar(): called
		  ```
	- 执行顺序
	  collapsed:: true
		- ```typescript
		  /**
		   * 实例方法参数装饰器
		   * 实例方法装饰器
		   * 实例属性装饰器
		   * 静态方法参数装饰器
		   * 静态方法装饰器
		   * 静态属性装饰器
		   * 构造函数装饰器
		   * 类装饰器
		   */
		  
		  function order(name: string) {
		      return function (_target: any, _propertyKey?: string | symbol, _descriptorOrIndex?: PropertyDescriptor | number) {
		          console.log(`Order decorator: ${name}`);
		      }
		  }
		  
		  @order('class')
		  class Foo {
		      constructor() {}
		  
		      @order('static method')
		      static staticMethod(@order('static method parameter') _param: string) {
		      }
		  
		      @order('class method')
		      method(@order('method parameter') _param: string) {
		      }
		  }
		  
		  new Foo()
		  // Order decorator: method parameter
		  // Order decorator: class method
		  // Order decorator: static method parameter
		  // Order decorator: static method
		  // Order decorator: class
		  ```
- 元数据
	- 元数据是“关于数据的数据”，在Typescript中，元数据是附加在**类、方法、属性、参数等上的额外信息**，信息不会影响代码执行逻辑，但可以在**运行时**被读取和使用。
	- 元数据会存储在全局的`WeakMap`下，类似如下：
	  ```javascript
	  WeakMap {
	    [Class.prototype] -> {
	      "design:type": 
	    }
	  }
	  ```
	- 元数据键(`Metadata Keys`)
		- `"design:type"` 存储属性的类型
		- `"design:paramtypes"` 存储方法参数的类型数组
		- `"design:returntype"` 存储方法的返回类型
	- 元数据相关操作
	  ```typescript
	  Reflect.defineMetadata // 设置metadata
	  Reflect.getMetadata // 获取metadata
	  Reflect.getMetadataKeys // 获取所有metadata key
	  ```
	- `reflect-metadata`
	-
-
-